<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#0b0f19" />
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="apple-touch-icon" href="./icons/icon-192.png">
  <title>VR Explorer Pro</title>
  <link rel="manifest" href="./manifest.json" />
  <style>
    :root { --bg:#0b0f19; --fg:#e5e7eb; --muted:#9aa3b2; }
    html,body {
      height:100%; margin:0; background:var(--bg); color:var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
      overscroll-behavior: none;
    }
    #app { position:fixed; inset:0; overflow:hidden; z-index:0; }
    canvas { display:block; width:100%; height:100%; background:#000; }
    .ui { position:fixed; inset:0; display:grid; place-items:center; z-index:10; pointer-events:auto; }
    .ui-inner { display:flex; flex-direction:column; gap:.8rem; align-items:center; }
    h1.appTitle {
      margin:0 0 .35rem; font-size:1.5rem; font-weight:700; letter-spacing:.2px; font-style: italic;
    }
    button {
      appearance:none; border:0; padding:1rem 1.2rem; border-radius:1rem;
      background:#121a2b; color:var(--fg); font-weight:600; letter-spacing:.2px;
      box-shadow:0 6px 24px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05);
      width:220px; cursor:pointer;
    }
    button:active { transform: translateY(1px); }
    .title { font-style: italic; color: var(--muted); font-size:.9rem; margin-top:.25rem; }
    .hidden { opacity:0; transform: translateY(8px); pointer-events:none; }
    .visible { opacity:1; transform: translateY(0); }
    .fade { transition: opacity .25s ease, transform .25s ease; }
    #file { position:fixed; width:1px; height:1px; opacity:0; pointer-events:none; }
  </style>
</head>
<body>
  <div id="app"></div>

  <div class="ui">
    <div id="ui" class="ui-inner fade visible">
      <h1 class="appTitle">VR Explorer Pro</h1>
      <button id="selectBtn" type="button">Select simulation</button>
      <button id="vrBtn" type="button" disabled>Enter VR</button>
      <button id="installBtn" type="button" style="display:none;">Install App</button>
      <div class="title">Brought to you by Cambridge VR</div>
      <div class="title" style="font-size:0.75rem; opacity:0.7; margin-top:-0.2rem;">v2.5</div>
    </div>
  </div>

  <input id="file" type="file" accept="video/*" />

  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/controls/DeviceOrientationControls.js"></script>

  <script>
  (function(){
    const app = document.getElementById('app');

    // ==== Wake lock + fullscreen ====
    let wakeLock = null;
    async function requestWakeLock(){ try { if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen'); } catch(e){} }
    document.addEventListener('visibilitychange', async () => {
      if (wakeLock !== null && document.visibilityState === 'visible') {
        try { wakeLock = await navigator.wakeLock.request('screen'); } catch(e){}
      }
    });
    async function goFullscreen(){
      const el = document.documentElement;
      try {
        if (el.requestFullscreen) await el.requestFullscreen();
        else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
      } catch(e){}
    }

    // ==== Video / scene setup ====
    const video = document.createElement('video');
    video.setAttribute('playsinline','');
    video.loop = true;     // ensure looping by default
    video.preload = 'metadata';
    video.crossOrigin = 'anonymous';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0,0,0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    renderer.setClearColor(0x000000, 1); // black background
    app.appendChild(renderer.domElement);

    let sphere, material, texture;
    function buildSphere(){
      const geometry = new THREE.SphereGeometry(500, 64, 64);
      geometry.scale(-1,1,1);
      texture = new THREE.VideoTexture(video);
      texture.colorSpace = THREE.SRGBColorSpace;
      material = new THREE.MeshBasicMaterial({ map: texture });
      sphere = new THREE.Mesh(geometry, material);
      scene.add(sphere);
    }
    buildSphere();

    let controls = null;
    try {
      if (THREE.DeviceOrientationControls) {
        controls = new THREE.DeviceOrientationControls(camera,true);
        controls.connect();
      }
    } catch(e){ console.warn('DeviceOrientationControls unavailable'); }

    let mode = 'mono';

    // ===== VERY SMOOTH XR SMOOTHING (no rebound, slow & smooth) =====
    let lastXrTime = null;
    let smoothedXrYaw = 0;

    // Time constant for low-pass filter (bigger = slower, smoother)
    const YAW_SMOOTH_TAU = 0.35; // seconds

    function _normalizeAngleRad(a){ return Math.atan2(Math.sin(a), Math.cos(a)); }

    const xrLoop = (time, frame) => {
      let dt = 0.016;
      if (lastXrTime !== null) dt = Math.max(0.001, (time - lastXrTime) / 1000);
      lastXrTime = time;

      const xrCam = renderer.xr.getCamera();
      const e = new THREE.Euler().setFromQuaternion(xrCam.quaternion, 'YXZ');
      const targetYaw = _normalizeAngleRad(e.y);

      // First-order exponential smoothing on yaw (no velocity integration → no rebound)
      const alpha = 1 - Math.exp(-dt / YAW_SMOOTH_TAU); // 0..1
      smoothedXrYaw = _normalizeAngleRad(smoothedXrYaw + (targetYaw - smoothedXrYaw) * alpha);

      sphere.rotation.y = -smoothedXrYaw;
      renderer.render(scene, xrCam);
    };
    // ===== END VERY SMOOTH XR SMOOTHING =====

    // Mono render: keep background black, no preview
    function renderMono(){
      renderer.setScissorTest(false);
      renderer.setClearColor(0x000000, 1);
      renderer.clear(true, true, true);
    }

    function animate(){
      if(mode==='webxr') return;
      requestAnimationFrame(animate);
      renderMono();
    }
    animate();

    function onResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    }
    window.addEventListener('resize', onResize);

    // --- UI logic: always visible ---
    const ui = document.getElementById('ui');
    ui.classList.add('visible');
    ui.classList.remove('hidden');

    const selectBtn = document.getElementById('selectBtn');
    const vrBtn = document.getElementById('vrBtn');
    const installBtn = document.getElementById('installBtn');
    const fileInput = document.getElementById('file');

    // === FALLBACK: original <input type="file"> (with audio) ===
    function useFileInputFallback(){
      fileInput.value = '';
      if(fileInput.showPicker){
        try{
          fileInput.showPicker();
          return;
        }catch(e){}
      }
      fileInput.click();
    }

    fileInput.addEventListener('change', e => {
      const f = e.target.files[0]; if(!f) return;
      video.src = URL.createObjectURL(f);
      video.loop = true;
      video.muted = false; // play with audio
      video.play().then(()=> vrBtn.disabled = false).catch(()=>{});
    });

    // === Simple IndexedDB storage for directory handle ===
    function openDb(){
      return new Promise((resolve, reject) => {
        if (!('indexedDB' in window)) {
          resolve(null);
          return;
        }
        const req = indexedDB.open('vr-explorer-pro', 1);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains('handles')) {
            db.createObjectStore('handles');
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function saveDirHandle(handle){
      try{
        const db = await openDb();
        if(!db) return;
        await new Promise((resolve,reject)=>{
          const tx = db.transaction('handles','readwrite');
          tx.objectStore('handles').put(handle, 'downloadsDir');
          tx.oncomplete = () => { db.close(); resolve(); };
          tx.onerror = () => { db.close(); reject(tx.error); };
        });
      }catch(e){
        console.warn('Could not save directory handle', e);
      }
    }

    async function loadDirHandle(){
      try{
        const db = await openDb();
        if(!db) return null;
        return await new Promise((resolve,reject)=>{
          const tx = db.transaction('handles','readonly');
          const store = tx.objectStore('handles');
          const req = store.get('downloadsDir');
          req.onsuccess = () => { resolve(req.result || null); };
          req.onerror = () => { reject(req.error); };
          tx.oncomplete = () => db.close();
        });
      }catch(e){
        console.warn('Could not load directory handle', e);
        return null;
      }
    }

    // === Full-screen overlay "window" for curated list ===
    const overlay = document.createElement('div');
    overlay.style.position = 'fixed';
    overlay.style.inset = '0';
    overlay.style.background = 'rgba(11,15,25,0.98)';
    overlay.style.display = 'none';
    overlay.style.zIndex = '20';
    overlay.style.justifyContent = 'center';
    overlay.style.alignItems = 'center';

    const overlayInner = document.createElement('div');
    overlayInner.style.display = 'flex';
    overlayInner.style.flexDirection = 'column';
    overlayInner.style.alignItems = 'center';
    overlayInner.style.gap = '0.75rem';
    overlayInner.style.padding = '1.2rem';
    overlayInner.style.borderRadius = '1.25rem';
    overlayInner.style.background = '#111827';
    overlayInner.style.boxShadow = '0 18px 45px rgba(0,0,0,0.6)';
    overlay.appendChild(overlayInner);

    const overlayTitle = document.createElement('div');
    overlayTitle.textContent = 'Select a simulation';
    overlayTitle.style.fontWeight = '600';
    overlayTitle.style.marginBottom = '0.25rem';
    overlayInner.appendChild(overlayTitle);

    const fileListContainer = document.createElement('div');
    fileListContainer.id = 'fileList';
    fileListContainer.style.maxHeight = '260px';
    fileListContainer.style.overflowY = 'auto';
    fileListContainer.style.fontSize = '.9rem';
    fileListContainer.style.width = '260px';
    fileListContainer.style.textAlign = 'left';
    fileListContainer.style.borderRadius = '0.75rem';
    fileListContainer.style.padding = '0.4rem 0.6rem';
    fileListContainer.style.background = '#020617';
    overlayInner.appendChild(fileListContainer);

    const overlayButtons = document.createElement('div');
    overlayButtons.style.display = 'flex';
    overlayButtons.style.justifyContent = 'space-between';
    overlayButtons.style.gap = '0.75rem';
    overlayButtons.style.marginTop = '0.5rem';
    overlayInner.appendChild(overlayButtons);

    const closeOverlayBtn = document.createElement('button');
    closeOverlayBtn.type = 'button';
    closeOverlayBtn.textContent = 'Back';
    closeOverlayBtn.style.width = '120px';
    overlayButtons.appendChild(closeOverlayBtn);

    document.body.appendChild(overlay);

    closeOverlayBtn.addEventListener('click', () => {
      overlay.style.display = 'none';
    });

    // === Directory + listing logic ===
    let dirHandle = null;
    let videoFiles = [];

    async function ensureDirectoryHandle(){
      // Try to reuse a stored handle first
      if (!dirHandle) {
        dirHandle = await loadDirHandle();
      }

      // Check permission if possible
      if (dirHandle && dirHandle.queryPermission) {
        try{
          let perm = await dirHandle.queryPermission({ mode: 'read' });
          if (perm === 'prompt') {
            perm = await dirHandle.requestPermission({ mode: 'read' });
          }
          if (perm !== 'granted') {
            dirHandle = null;
          }
        }catch(e){
          dirHandle = null;
        }
      }

      // If still none, ask user to pick Downloads (first-time flow)
      if (!dirHandle) {
        if (!window.showDirectoryPicker) return null;
        try{
          dirHandle = await window.showDirectoryPicker({
            id: 'vr-explorer-downloads',
            startIn: 'downloads'
          });
          await saveDirHandle(dirHandle);
        }catch(e){
          dirHandle = null;
        }
      }

      return dirHandle;
    }

    async function buildFileListFromDir(){
      const handle = await ensureDirectoryHandle();
      if (!handle) {
        // no directory available → fallback to classic file picker
        useFileInputFallback();
        return false;
      }

      const files = [];
      try{
        for await (const [name, entry] of handle.entries()){
          if (entry.kind === 'file' && name.toLowerCase().endsWith('.mp4')) {
            files.push({ name, handle: entry });
          }
        }
      }catch(e){
        console.warn('Error reading directory contents', e);
        useFileInputFallback();
        return false;
      }

      files.sort((a,b)=> a.name.localeCompare(b.name, undefined, { numeric:true, sensitivity:'base' }));
      videoFiles = files;
      renderFileList();
      return true;
    }

    function renderFileList(){
      fileListContainer.innerHTML = '';

      if (!videoFiles.length) {
        fileListContainer.textContent = 'No .mp4 files found in this folder.';
        return;
      }

      const list = document.createElement('ul');
      list.style.listStyle = 'none';
      list.style.padding = '0';
      list.style.margin = '0';

      videoFiles.forEach((fileObj, index)=>{
        const li = document.createElement('li');
        li.style.padding = '.3rem 0';
        li.style.cursor = 'pointer';
        li.style.borderBottom = '1px solid rgba(148,163,184,0.25)';

        const displayName = fileObj.name.replace(/\.mp4$/i, '');
        li.textContent = displayName;

        li.addEventListener('click', () => {
          selectVideoFromList(index);
        });

        list.appendChild(li);
      });

      fileListContainer.appendChild(list);
    }

    async function selectVideoFromList(index){
      const fileObj = videoFiles[index];
      if(!fileObj) return;
      try{
        const file = await fileObj.handle.getFile();
        const url = URL.createObjectURL(file);
        video.src = url;
        video.loop = true;
        video.muted = false; // allow audio
        await video.play().then(()=>{ vrBtn.disabled = false; }).catch(()=>{});
      }catch(e){
        console.error('Failed to load selected video:', e);
      } finally {
        // Return to main UI after selecting (black background)
        overlay.style.display = 'none';
      }
    }

    // === Button behaviour ===
    selectBtn.addEventListener('click', async ()=>{
      // If browser doesn't support directory picker, just behave like old version
      if (!window.showDirectoryPicker) {
        useFileInputFallback();
        return;
      }

      const ok = await buildFileListFromDir();
      if (ok) {
        // Show curated list "window"
        overlay.style.display = 'flex';
      }
    });

    async function enterWebXR(){
      try{
        const ok = await (navigator.xr && navigator.xr.isSessionSupported('immersive-vr'));
        if(!ok) return false;
        const session = await navigator.xr.requestSession('immersive-vr',{optionalFeatures:['local-floor']});
        renderer.xr.setReferenceSpaceType('local');
        renderer.setAnimationLoop(xrLoop);
        await renderer.xr.setSession(session);
        lastXrTime = null;
        smoothedXrYaw = 0;
        mode = 'webxr';

        // When XR session ends, return to black main UI
        session.addEventListener('end', () => {
          mode = 'mono';
          renderer.setAnimationLoop(null);
          lastXrTime = null;
          smoothedXrYaw = 0;
          try { video.pause(); } catch(e){}
          animate(); // restart mono loop (black background)
        });

        return true;
      }catch{
        return false;
      }
    }

    async function enterVR(){
      const ok = await enterWebXR();
      if(!ok){
        await goFullscreen();
        mode='stereo';
      }
    }
    vrBtn.addEventListener('click', enterVR);

    // === PWA install flow (beforeinstallprompt) ===
    let deferredInstallPrompt = null;

    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredInstallPrompt = e;
      if (installBtn) {
        installBtn.style.display = 'block';  // show the Install App button
      }
    });

    if (installBtn) {
      installBtn.addEventListener('click', async () => {
        if (!deferredInstallPrompt) return;
        const promptEvent = deferredInstallPrompt;
        deferredInstallPrompt = null;
        promptEvent.prompt();
        try {
          const choice = await promptEvent.userChoice;
          if (choice.outcome === 'accepted') {
            installBtn.style.display = 'none';
          }
        } catch(e) {}
      });
    }

    // === Service worker for offline PWA ===
    if('serviceWorker' in navigator){
      window.addEventListener('load', async ()=>{
        try{
          const reg = await navigator.serviceWorker.register('./sw.js?v=25',{scope:'./'});
          if(reg.waiting) reg.waiting.postMessage('SKIP_WAITING');
        }catch(e){}
      });
    }
  })();
  </script>
</body>
</html>
